#!/usr/bin/env python

__usage__ = "compute_psd [--options] channel frametype gpsstart gpsstop"
__description__ = "a very basic executable that computes a PSD estimate based on the time between [gpsstart, gpsstop]. NOTE: if the derived set of segments is not contiguous throughout [gpsstart, gpsstop], we raise an exception."
__author__ = "Reed Essick (reed.essick@ligo.org)"

#-------------------------------------------------

import os
import gzip
import subprocess as sp

from optparse import OptionParser

### non-standard libraries
from exposure import utils
from exposure import datafind
from exposure import dft

#-------------------------------------------------

parser = OptionParser(usage=__usage__, description=__description__)

parser.add_option("-v", "--verbose", default=False, action="store_true")
parser.add_option("-V", "--Verbose", default=False, action="store_true")

parser.add_option("", "--include-flag", default=[], type='string', action='append',
    help='the flags used to select subsets of [gpsstart, gpsstop] for analysis. \
Can be repeated to take the intersection of multiple flags. \
DEFAULT=[] (analyze all time in [gpsstart, gpsstop]).')
parser.add_option("", "--exclude-flag", default=[], type='string', action='append',
    help='the same as --include-flag, except we only retain times that are \
outside of these flags instead of inside them')

parser.add_option("", "--seglen", default=dft.DEFAULT_SEGLEN, type='int',
    help='the length of segments used to estimate the PSD via an averaging procedure (specify in seconds). \
NOTE: if we do not obtain an integer number of segments based on --seglen, --overlap, gpsstart, and gpsstop, \
we will raise a ValueError. DEFAULT=%d'%dft.DEFAULT_SEGLEN)
parser.add_option("", "--overlap", default=dft.DEFAULT_OVERLAP, type='float',
    help='the amount of time overlapped for segments used to estimate the PSD (specify in seconds). \
NOTE: if we do not obtain an integer number of segments based on --seglen, --overlap, gpsstart, and gpsstop, \
we will raise a ValueError. DEFAULT=%.3f'%dft.DEFAULT_OVERLAP)
parser.add_option("", "--tukey-alpha", default=dft.DEFAULT_TUKEY_ALPHA, type='float',
    help='the Tukey "alpha" value used for windowing the DFT. \
DEFAULT=%.3f'%dft.DEFAULT_TUKEY_ALPHA)

parser.add_option("-o", "--output-dir", default='.', type='string')
parser.add_option("-t", "--tag", default="", type='string')

opts, args = parser.parse_args()
assert len(args)==4, 'please supply exactly 4 arguments\n%s'%__usage__
channel, frametype = args[:2]
gpsstart, gpsstop = [int(_) for _ in args[2:]]
stride = gpsstop - gpsstart

assert channel[0]==frametype[0], 'I do not believe you want a channel and frametype \
from different IFOs\n\tchannel : %s\n\tframetype : %s\n%s'%(channel, frametype, __usage__)

assert opts.seglen > opts.overlap, '--seglen must be larger than --overlap\n\%s'%__usage__

if opts.tag:
    opts.tag = "_"+opts.tag

if not os.path.exists(opts.output_dir):
    os.makedirs(opts.output_dir)

opts.verbose |= opts.Verbose

#-------------------------------------------------

### ensure we have proper coverage
segments = [[gpsstart, gpsstop]]

segments = datafind.include_flags(segments, opts.include_flag, gpsstart, stride, verbose=opts.verbose)
segments = datafind.exclude_flags(segments, opts.exclude_flag, gpsstart, stride, verbose=opts.verbose)

assert segments, 'no remaining livetime after filtering by flags!'
assert len(segments)==1, 'more than one segment after filtering by flags!'
assert segments[0][0]==gpsstart and segments[0][1]==gpsstop, 'segments to not cover entire requested time period!'

#------------------------

### grab frames
frames = datafind.gw_data_find(channel[0], frametype, gpsstart, gpsstop-gpsstart, verbose=opts.verbose)

### insure we have full coverage
segs = utils.andsegments(segments, utils.mergesegments([(s,s+d) for _, s, d in frames]))

assert segs, 'no frame data found!'
assert len(segs)==1, 'gap in frame data found!'
assert segs[0][0]==gpsstart and segs[0][1]==gpsstop, 'frame data does not cover entire requested time period!'

#-------------------------------------------------

### read in data
if opts.verbose:
    print( 'reading data' )
vect, dt = datafind.vec_from_frames(frames, channel, gpsstart, gpsstop, verbose=opts.Verbose)

### compute PSD
n = 1 + 1.*(gpsstop - gpsstart - opts.seglen)/(opts.seglen - opts.overlap)
assert n%1==0, 'must be an integer number of segments used to compute PSD! Check your combination of gpsstart, gpsstop, --seglen, and --overlap'
n = int(n)

overlap = 1.*opts.overlap/opts.seglen ### the fractional overlap we want
if opts.verbose:
    print( 'estimating PSD using %d segments with %.3f fractional overlap'%(n, overlap) )
psd, freqs = dft.estimate_psd(vect, num_segs=n, overlap=overlap, dt=dt, tukey_alpha=opts.tukey_alpha)

### write PSD
path = utils.psd_path(opts.output_dir, opts.tag, gpsstart, gpsstop-gpsstart)
if opts.verbose:
    print( "writing : "+path )
utils.report_psd(psdpath, freqs, psd)
